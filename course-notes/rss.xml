<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title> =^..^= MEH</title><link>https://chowy1026.github.io/</link><description></description><atom:link rel="self" href="https://chowy1026.github.io/course-notes/rss.xml" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Fri, 21 Apr 2017 06:08:09 GMT</lastBuildDate><generator>https://getnikola.com/</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Evaluation Metrics</title><link>https://chowy1026.github.io/course-notes/machine-learning/14-evaluation_metrics/</link><dc:creator>cHoWy</dc:creator><description>&lt;div&gt;&lt;p&gt;The simplest metric is Accuracy.  It is defined as :&lt;/p&gt;
&lt;p&gt;Accuracy = no. of items in a class labeled correctly / all items in that class&lt;/p&gt;
&lt;p&gt;There are shortcomings of accuracy:      &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;not ideal for skewed classes    &lt;/li&gt;
&lt;li&gt;may want to err on side of guessing innocent   &lt;/li&gt;
&lt;li&gt;may want to err of side of guessing guilty   &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Model Evaluation Metrics&lt;/h3&gt;
&lt;p&gt;There are 3 different approaches to evaluate the quality of predictions of a model:    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Estimator score method&lt;/strong&gt;: Estimators have a score method providing a default evaluation criterion for the problem they are designed to solve. This is not discussed on this page, but in each estimator’s documentation.     &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Scoring parameter&lt;/strong&gt;: Model-evaluation tools using &lt;a href="http://scikit-learn.org/stable/modules/cross_validation.html#cross-validation" title="Cross Validation"&gt;cross-validation&lt;/a&gt; (such as model_selection.cross_val_score and model_selection.GridSearchCV) rely on an internal scoring strategy. This is discussed in the section &lt;a href="http://scikit-learn.org/stable/modules/model_evaluation.html#scoring-parameter" title="Scoring Parameter"&gt;The scoring parameter: defining model evaluation rules&lt;/a&gt;.     &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Metric functions&lt;/strong&gt;: The metrics module implements functions assessing prediction error for specific purposes. These metrics are detailed in sections on &lt;a href="http://scikit-learn.org/stable/modules/model_evaluation.html#classification-metrics" title="Classification Metrics"&gt;Classification metrics&lt;/a&gt;, &lt;a href="http://scikit-learn.org/stable/modules/model_evaluation.html#multilabel-ranking-metrics" title="Multilabel Ranking Metrics"&gt;Multilabel ranking metrics&lt;/a&gt;, &lt;a href="http://scikit-learn.org/stable/modules/model_evaluation.html#regression-metrics" title="Regression Metrics"&gt;Regression metrics&lt;/a&gt; and &lt;a href="http://scikit-learn.org/stable/modules/model_evaluation.html#clustering-metrics" title="Clustering Metrics"&gt;Clustering metrics&lt;/a&gt;.     &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Finally, Dummy estimators are useful to get a baseline value of those metrics for random predictions.&lt;/p&gt;
&lt;p&gt;For the most common use cases, you can designate a scorer object with the scoring parameter; the table below shows all possible values. All scorer objects follow the convention that &lt;strong&gt;higher return values are better than lower return values&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Classification&lt;/strong&gt;:       &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;confusion matrix&lt;/li&gt;
&lt;li&gt;accuracy   &lt;/li&gt;
&lt;li&gt;average precision     &lt;/li&gt;
&lt;li&gt;precision score    &lt;/li&gt;
&lt;li&gt;recall score    &lt;/li&gt;
&lt;li&gt;f1 score (micro, macro, weighted, samples)    &lt;/li&gt;
&lt;li&gt;roc auc (area under curve)      &lt;/li&gt;
&lt;li&gt;log loss&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Clustering&lt;/strong&gt;:       &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;adjusted rand score&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Regression&lt;/strong&gt;:      &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Mean absolute error&lt;/li&gt;
&lt;li&gt;Mean square error&lt;/li&gt;
&lt;li&gt;Median absolute error&lt;/li&gt;
&lt;li&gt;\(r^2\) score&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Confusion Matrix&lt;/h3&gt;
&lt;p&gt;In the field of &lt;a href="https://en.wikipedia.org/wiki/Machine_learning" title="Machine Learning"&gt;machine learning&lt;/a&gt; and specifically the problem of &lt;a href="https://en.wikipedia.org/wiki/Statistical_classification" title="Statistical Classification"&gt;statistical classification&lt;/a&gt;, a &lt;strong&gt;confusion matrix&lt;/strong&gt;, also known as an error matrix,[4] is a specific table layout that allows visualization of the performance of an algorithm, typically a &lt;a href="https://en.wikipedia.org/wiki/Supervised_learning" title="Supervised Learning"&gt;supervised learning&lt;/a&gt; one (in &lt;a href="https://en.wikipedia.org/wiki/Unsupervised_learning" title="Unsupervised Learning"&gt;unsupervised learning&lt;/a&gt; it is usually called a &lt;strong&gt;matching matrix&lt;/strong&gt;). Each column of the matrix represents the instances in a predicted class while each row represents the instances in an actual class (or vice versa).   The name stems from the fact that it makes it easy to see if the system is confusing two classes (i.e. commonly mislabelling one as another).&lt;/p&gt;
&lt;p&gt;It is a special kind of &lt;a href="https://en.wikipedia.org/wiki/Contingency_table" title="Contingency Table"&gt;contingency table&lt;/a&gt;, with two dimensions ("actual" and "predicted"), and identical sets of "classes" in both dimensions (each combination of dimension and class is a variable in the contingency table).&lt;/p&gt;
&lt;h4&gt;NOTES FROM UDACITY CLASS:&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Recall&lt;/strong&gt;: True Positive / (True Positive + False Negative). Out of all the items that are truly positive, how many were correctly classified as positive. Or simply, how many positive items were 'recalled' from the dataset.      &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Precision&lt;/strong&gt;: True Positive / (True Positive + False Positive). Out of all the items labeled as positive, how many truly belong to the positive class.      &lt;/p&gt;
&lt;h4&gt;Terminology and derivations from a confusion matrix&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;condition positive (P)&lt;/strong&gt; :: the number of real positive cases in the data      &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;condition negatives (N)&lt;/strong&gt; :: the number of real negative cases in the data&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;true positive (TP)&lt;/strong&gt; :: eqv. with hit    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;true negative (TN)&lt;/strong&gt; :: eqv. with correct rejection    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;false positive (FP)&lt;/strong&gt; :: eqv. with &lt;a href="https://en.wikipedia.org/wiki/False_alarm" title="False Alarm"&gt;false alarm&lt;/a&gt;, &lt;a href="https://en.wikipedia.org/wiki/Type_I_error" title="Type I Error"&gt;Type I error&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;false negative (FN)&lt;/strong&gt; :: eqv. with miss, &lt;a href="https://en.wikipedia.org/wiki/Type_II_error" title="Type II Error"&gt;Type II error&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Sensitivity_(test)" title="Sensitivity"&gt;sensitivity&lt;/a&gt;, &lt;a href="https://en.wikipedia.org/wiki/Information_retrieval#Recall" title="Recall"&gt;recall&lt;/a&gt;, &lt;a href="https://en.wikipedia.org/wiki/Hit_rate" title="Hit Rate"&gt;hit rate&lt;/a&gt;, or &lt;a href="https://en.wikipedia.org/wiki/Sensitivity_(test)" title="True Positive Rate (TPR)"&gt;true positive rate (TPR)&lt;/a&gt; ::
\[
  \mathrm{TPR} = \frac{\mathrm{TP}}{P} = \frac{\mathrm{TP}}{\mathrm{TP} + \mathrm{FN}}
\]&lt;/p&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Specificity_(tests)" title="Speciticity"&gt;specificity&lt;/a&gt; or &lt;a href="https://en.wikipedia.org/wiki/Specificity_(tests)" title="True Negative Rate (TNR)"&gt;true negative rate (TNR)&lt;/a&gt; ::
\[
  \mathrm{TNR} = \frac{\mathrm{TN}}{N} = \frac{\mathrm{TN}}{\mathrm{TN} + \mathrm{FP}}
\]&lt;/p&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Information_retrieval#Precision" title="Precision"&gt;precision&lt;/a&gt; or &lt;a href="https://en.wikipedia.org/wiki/Positive_predictive_value" title="Positive Predictive Value"&gt;positive predictive value (PPV)&lt;/a&gt; :: &lt;br&gt;
\[
  \mathrm{PPV} = \frac{\mathrm{TP}}{\mathrm {TP} +\mathrm {FP}}
\]&lt;/p&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Negative_predictive_value" title="Negative Predictive Value"&gt;negative predictive value (NPV)&lt;/a&gt; ::  &lt;br&gt;
\[
  \mathrm{NPV} = \frac{\mathrm{TN}}{\mathrm {TN} +\mathrm {FN}}
\]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;miss rate&lt;/strong&gt; or &lt;a href="https://en.wikipedia.org/wiki/Type_I_and_type_II_errors#False_positive_and_false_negative_rates" title="False Negative Rate"&gt;false negative rate (FNR)&lt;/a&gt; :: &lt;br&gt;
\[
  \mathrm{FNR} = \frac{\mathrm{FN}}{P} = \frac{\mathrm{FN}}{\mathrm{FN} + \mathrm{TP}} = 1 - \mathrm{TPR}
\]&lt;/p&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Information_retrieval#Fall-out" title="Fall Out"&gt;fall-out&lt;/a&gt; or &lt;a href="https://en.wikipedia.org/wiki/Information_retrieval#Fall-out" title="False Positive Rate"&gt;false positive rate (FPR)&lt;/a&gt; ::  &lt;br&gt;
\[
  \mathrm{FPR} = \frac{\mathrm{FP}}{N} = \frac{\mathrm{FP}}{\mathrm{FP} + \mathrm{TN}} = 1 - \mathrm{TNP}
\]&lt;/p&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/False_discovery_rate" title="False Discovery Rate"&gt;false discovery rate (FDR)&lt;/a&gt; ::   &lt;br&gt;
\[
  \mathrm{FDR} = \frac{\mathrm{FP}}{\mathrm {FP} +\mathrm {TP}} = 1 - \mathrm{PPV}
\]&lt;/p&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Positive_and_negative_predictive_values" title="False Omission Rate"&gt;false omission rate (FOR)&lt;/a&gt;  ::    &lt;br&gt;
\[
  \mathrm{FOR} = \frac{\mathrm{FN}}{\mathrm {FN} +\mathrm {TN}} = 1 - \mathrm{NPV}
\]&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Accuracy" title="Accuracy"&gt;accuracy (ACC)&lt;/a&gt; ::  &lt;br&gt;
\[
  \mathrm{ACC} = \frac{\mathrm{TP} + \mathrm{TN}}{ {P} + {N}}
\]&lt;/p&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/F1_score" title="F1 Score"&gt;F1 score&lt;/a&gt; :: is the &lt;a href="https://en.wikipedia.org/wiki/Harmonic_mean#Harmonic_mean_of_two_numbers" title="Harmonic Mean"&gt;harmonic mea&lt;/a&gt;n of &lt;a href="https://en.wikipedia.org/wiki/Information_retrieval#Precision" title="Precision"&gt;precision&lt;/a&gt; and &lt;a href="https://en.wikipedia.org/wiki/Sensitivity_(test)" title="Sensitivity"&gt;sensitivity&lt;/a&gt;     &lt;br&gt;
\[
  F_{1} = 2 \cdot \frac{\mathrm{PPV} \cdot \mathrm{TPR}}{\mathrm{PPV} + \mathrm{TPR}} =  \frac{2\mathrm{TP}}{2\mathrm{TP} + \mathrm{FP} + \mathrm{FN}}
\]&lt;/p&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Matthews_correlation_coefficient" title="Matthews Correlation Coefficient"&gt;Matthews correlation coefficient (MCC)&lt;/a&gt; ::   &lt;br&gt;
\[
  \mathrm{MCC} = \frac{ \mathrm{TP} \times \mathrm{TN} - \mathrm{FP} \times \mathrm{FN} }{ \sqrt{(\mathrm{TP} + \mathrm{FP} )(\mathrm{TP} + \mathrm{FN} )( \mathrm{TN} + \mathrm{FP} )( \mathrm{TN} + \mathrm{FN} )} }
\]&lt;/p&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Informedness" title="Informedness"&gt;Informedness&lt;/a&gt; or &lt;strong&gt;Bookmaker Informedness (BM)&lt;/strong&gt; ::   &lt;br&gt;
\[
  \mathrm{BM}  = \mathrm{TPR} + \mathrm{TNR} -1
\]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Markedness (MK)&lt;/strong&gt; ::    &lt;br&gt;
\[
  \mathrm{MK}  = \mathrm{PPV} + \mathrm{NPV} -1
\]&lt;/p&gt;
&lt;hr&gt;
&lt;table class="wikitable" align="center" style="text-align:center; border:none; background:transparent;"&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td colspan="2" style="border:none;"&gt;&lt;/td&gt;
&lt;td colspan="2" style="background:#eeeebb;"&gt;&lt;b&gt;predicted condition&lt;/b&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="border:none;"&gt;&lt;/td&gt;
&lt;td style="background:#dddddd;"&gt;&lt;a href="https://en.wikipedia.org/wiki/Statistical_population" title="Statistical population"&gt;total population&lt;/a&gt;&lt;/td&gt;
&lt;td style="background:#ffffcc;"&gt;prediction positive&lt;/td&gt;
&lt;td style="background:#ddddaa;"&gt;prediction negative&lt;/td&gt;
&lt;td style="background:#eeeecc;"&gt;&lt;a href="https://en.wikipedia.org/wiki/Prevalence" title="Prevalence"&gt;Prevalence&lt;/a&gt; &lt;span style="font-size:118%;white-space:nowrap;"&gt;= &lt;span class="texhtml"&gt;&lt;span class="sfrac nowrap" style="display:inline-block; vertical-align:-0.5em; font-size:85%; text-align:center;"&gt;&lt;span style="display:block; line-height:1em; margin:0 0.1em;"&gt;Σ condition positive&lt;/span&gt;&lt;span style="display:block; line-height:1em; margin:0 0.1em; border-top:1px solid;"&gt;Σ total population&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td rowspan="2" style="background:#bbeeee;"&gt;&lt;b&gt;true&lt;br&gt;
condition&lt;/b&gt;&lt;/td&gt;
&lt;td style="background:#ccffff;"&gt;condition&lt;br&gt;
positive&lt;/td&gt;
&lt;td style="background:#ccffcc;"&gt;&lt;span style="color:#006600;"&gt;&lt;b&gt;&lt;a href="https://en.wikipedia.org/wiki/True_positive" class="mw-redirect" title="True positive"&gt;True Positive (TP)&lt;/a&gt;&lt;/b&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td style="background:#eedddd;"&gt;&lt;span style="color:#cc0000;"&gt;&lt;b&gt;&lt;a href="https://en.wikipedia.org/wiki/False_Negative" class="mw-redirect" title="False Negative"&gt;False Negative (FN)&lt;/a&gt;&lt;/b&gt;&lt;/span&gt;&lt;br&gt;
(&lt;a href="https://en.wikipedia.org/wiki/Type_II_error" class="mw-redirect" title="Type II error"&gt;type II error&lt;/a&gt;)&lt;/td&gt;
&lt;td style="background:#eeffcc;"&gt;&lt;a href="https://en.wikipedia.org/wiki/True_Positive_Rate" class="mw-redirect" title="True Positive Rate"&gt;True Positive Rate (TPR)&lt;/a&gt;, &lt;a href="https://en.wikipedia.org/wiki/Sensitivity_(tests)" class="mw-redirect" title="Sensitivity (tests)"&gt;Sensitivity&lt;/a&gt;, &lt;a href="https://en.wikipedia.org/wiki/Recall_(information_retrieval)" class="mw-redirect" title="Recall (information retrieval)"&gt;Recall&lt;/a&gt;, Probability of Detection &lt;span style="font-size:118%;white-space:nowrap;"&gt;= &lt;span class="texhtml"&gt;&lt;span class="sfrac nowrap" style="display:inline-block; vertical-align:-0.5em; font-size:85%; text-align:center;"&gt;&lt;span style="display:block; line-height:1em; margin:0 0.1em;"&gt;Σ TP&lt;/span&gt;&lt;span style="display:block; line-height:1em; margin:0 0.1em; border-top:1px solid;"&gt;Σ condition positive&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td style="background:#ffeecc;"&gt;&lt;a href="https://en.wikipedia.org/wiki/False_Negative_Rate" class="mw-redirect" title="False Negative Rate"&gt;False Negative Rate (FNR)&lt;/a&gt;, Miss Rate &lt;span style="font-size:118%;white-space:nowrap;"&gt;= &lt;span class="texhtml"&gt;&lt;span class="sfrac nowrap" style="display:inline-block; vertical-align:-0.5em; font-size:85%; text-align:center;"&gt;&lt;span style="display:block; line-height:1em; margin:0 0.1em;"&gt;Σ FN&lt;/span&gt;&lt;span style="display:block; line-height:1em; margin:0 0.1em; border-top:1px solid;"&gt;Σ condition positive&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="background:#aadddd;"&gt;condition&lt;br&gt;
negative&lt;/td&gt;
&lt;td style="background:#ffdddd;"&gt;&lt;span style="color:#cc0000;"&gt;&lt;b&gt;&lt;a href="https://en.wikipedia.org/wiki/False_Positive" class="mw-redirect" title="False Positive"&gt;False Positive (FP)&lt;/a&gt;&lt;/b&gt;&lt;/span&gt;&lt;br&gt;
(&lt;a href="https://en.wikipedia.org/wiki/Type_I_error" class="mw-redirect" title="Type I error"&gt;Type I error&lt;/a&gt;)&lt;/td&gt;
&lt;td style="background:#bbeebb;"&gt;&lt;span style="color:#006600;"&gt;&lt;b&gt;&lt;a href="https://en.wikipedia.org/wiki/True_negative" class="mw-redirect" title="True negative"&gt;True Negative (TN)&lt;/a&gt;&lt;/b&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td style="background:#eeddbb;"&gt;&lt;a href="https://en.wikipedia.org/wiki/False_Positive_Rate" class="mw-redirect" title="False Positive Rate"&gt;False Positive Rate (FPR)&lt;/a&gt;, &lt;a href="https://en.wikipedia.org/wiki/Information_retrieval" title="Information retrieval"&gt;&lt;span class="nowrap"&gt;Fall-out&lt;/span&gt;&lt;/a&gt;, Probability of False Alarm &lt;span style="font-size:118%;white-space:nowrap;"&gt;= &lt;span class="texhtml"&gt;&lt;span class="sfrac nowrap" style="display:inline-block; vertical-align:-0.5em; font-size:85%; text-align:center;"&gt;&lt;span style="display:block; line-height:1em; margin:0 0.1em;"&gt;Σ FP&lt;/span&gt;&lt;span style="display:block; line-height:1em; margin:0 0.1em; border-top:1px solid;"&gt;Σ condition negative&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td style="background:#ddeebb;"&gt;&lt;a href="https://en.wikipedia.org/wiki/True_Negative_Rate" class="mw-redirect" title="True Negative Rate"&gt;True Negative Rate (TNR)&lt;/a&gt;, &lt;a href="https://en.wikipedia.org/wiki/Specificity_(tests)" class="mw-redirect" title="Specificity (tests)"&gt;Specificity&lt;/a&gt; (SPC) &lt;span style="font-size:118%;white-space:nowrap;"&gt;= &lt;span class="texhtml"&gt;&lt;span class="sfrac nowrap" style="display:inline-block; vertical-align:-0.5em; font-size:85%; text-align:center;"&gt;&lt;span style="display:block; line-height:1em; margin:0 0.1em;"&gt;Σ TN&lt;/span&gt;&lt;span style="display:block; line-height:1em; margin:0 0.1em; border-top:1px solid;"&gt;Σ condition negative&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="border:none;"&gt;&lt;/td&gt;
&lt;td rowspan="2" style="background:#cceecc;border-top:solid grey;border-right:solid grey"&gt;&lt;a href="https://en.wikipedia.org/wiki/Accuracy_and_precision" title="Accuracy and precision"&gt;Accuracy&lt;/a&gt; &lt;span style="font-size:118%;white-space:nowrap;"&gt;= &lt;span class="texhtml"&gt;&lt;span class="sfrac nowrap" style="display:inline-block; vertical-align:-0.5em; font-size:85%; text-align:center;"&gt;&lt;span style="display:block; line-height:1em; margin:0 0.1em;"&gt;Σ TP + Σ TN&lt;/span&gt;&lt;span style="display:block; line-height:1em; margin:0 0.1em; border-top:1px solid;"&gt;Σ total population&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td style="background:#ccffee;border-top:solid grey;"&gt;&lt;a href="https://en.wikipedia.org/wiki/Positive_Predictive_Value" class="mw-redirect" title="Positive Predictive Value"&gt;Positive Predictive Value (PPV)&lt;/a&gt;, &lt;a href="https://en.wikipedia.org/wiki/Precision_(information_retrieval)" class="mw-redirect" title="Precision (information retrieval)"&gt;Precision&lt;/a&gt; &lt;span style="font-size:118%;white-space:nowrap;"&gt;= &lt;span class="texhtml"&gt;&lt;span class="sfrac nowrap" style="display:inline-block; vertical-align:-0.5em; font-size:85%; text-align:center;"&gt;&lt;span style="display:block; line-height:1em; margin:0 0.1em;"&gt;Σ TP&lt;/span&gt;&lt;span style="display:block; line-height:1em; margin:0 0.1em; border-top:1px solid;"&gt;Σ prediction positive&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td style="background:#eeddee;border-bottom:solid grey;"&gt;&lt;a href="https://en.wikipedia.org/wiki/False_omission_rate" class="mw-redirect" title="False omission rate"&gt;False Omission Rate (FOR)&lt;/a&gt; &lt;span style="font-size:118%;white-space:nowrap;"&gt;= &lt;span class="texhtml"&gt;&lt;span class="sfrac nowrap" style="display:inline-block; vertical-align:-0.5em; font-size:85%; text-align:center;"&gt;&lt;span style="display:block; line-height:1em; margin:0 0.1em;"&gt;Σ FN&lt;/span&gt;&lt;span style="display:block; line-height:1em; margin:0 0.1em; border-top:1px solid;"&gt;Σ prediction negative&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td style="background:#eeeeee;"&gt;&lt;a href="https://en.wikipedia.org/wiki/Positive_likelihood_ratio" class="mw-redirect" title="Positive likelihood ratio"&gt;Positive Likelihood Ratio &lt;span class="nowrap"&gt;(LR+)&lt;/span&gt;&lt;/a&gt; &lt;span style="font-size:118%;white-space:nowrap;"&gt;= &lt;span class="texhtml"&gt;&lt;span class="sfrac nowrap" style="display:inline-block; vertical-align:-0.5em; font-size:85%; text-align:center;"&gt;&lt;span style="display:block; line-height:1em; margin:0 0.1em;"&gt;TPR&lt;/span&gt;&lt;span style="display:block; line-height:1em; margin:0 0.1em; border-top:1px solid;"&gt;FPR&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td rowspan="2" style="background:#dddddd;"&gt;&lt;a href="https://en.wikipedia.org/wiki/Diagnostic_odds_ratio" title="Diagnostic odds ratio"&gt;Diagnostic Odds Ratio (DOR)&lt;/a&gt; &lt;span style="font-size:118%;white-space:nowrap;"&gt;= &lt;span class="texhtml"&gt;&lt;span class="sfrac nowrap" style="display:inline-block; vertical-align:-0.5em; font-size:85%; text-align:center;"&gt;&lt;span style="display:block; line-height:1em; margin:0 0.1em;"&gt;LR+&lt;/span&gt;&lt;span style="display:block; line-height:1em; margin:0 0.1em; border-top:1px solid;"&gt;LR−&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="border:none;"&gt;&lt;/td&gt;
&lt;td style="background:#cceeff;border-top:solid grey;"&gt;&lt;a href="https://en.wikipedia.org/wiki/False_Discovery_Rate" class="mw-redirect" title="False Discovery Rate"&gt;False Discovery Rate (FDR)&lt;/a&gt; &lt;span style="font-size:118%;white-space:nowrap;"&gt;= &lt;span class="texhtml"&gt;&lt;span class="sfrac nowrap" style="display:inline-block; vertical-align:-0.5em; font-size:85%; text-align:center;"&gt;&lt;span style="display:block; line-height:1em; margin:0 0.1em;"&gt;Σ FP&lt;/span&gt;&lt;span style="display:block; line-height:1em; margin:0 0.1em; border-top:1px solid;"&gt;Σ prediction positive&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td style="background:#aaddcc;border-bottom:solid grey;"&gt;&lt;a href="https://en.wikipedia.org/wiki/Negative_Predictive_Value" class="mw-redirect" title="Negative Predictive Value"&gt;Negative Predictive Value (NPV)&lt;/a&gt; &lt;span style="font-size:118%;white-space:nowrap;"&gt;= &lt;span class="texhtml"&gt;&lt;span class="sfrac nowrap" style="display:inline-block; vertical-align:-0.5em; font-size:85%; text-align:center;"&gt;&lt;span style="display:block; line-height:1em; margin:0 0.1em;"&gt;Σ TN&lt;/span&gt;&lt;span style="display:block; line-height:1em; margin:0 0.1em; border-top:1px solid;"&gt;Σ prediction negative&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td style="background:#cccccc;"&gt;&lt;a href="https://en.wikipedia.org/wiki/Negative_likelihood_ratio" class="mw-redirect" title="Negative likelihood ratio"&gt;Negative Likelihood Ratio &lt;span class="nowrap"&gt;(LR−)&lt;/span&gt;&lt;/a&gt; &lt;span style="font-size:118%;white-space:nowrap;"&gt;= &lt;span class="texhtml"&gt;&lt;span class="sfrac nowrap" style="display:inline-block; vertical-align:-0.5em; font-size:85%; text-align:center;"&gt;&lt;span style="display:block; line-height:1em; margin:0 0.1em;"&gt;FNR&lt;/span&gt;&lt;span style="display:block; line-height:1em; margin:0 0.1em; border-top:1px solid;"&gt;TNR&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;</description><guid>https://chowy1026.github.io/course-notes/machine-learning/14-evaluation_metrics/</guid><pubDate>Wed, 19 Apr 2017 23:04:44 GMT</pubDate></item><item><title>Validation</title><link>https://chowy1026.github.io/course-notes/machine-learning/13-validation/</link><dc:creator>cHoWy</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;strong&gt;Cross-validation&lt;/strong&gt;, sometimes called &lt;strong&gt;rotation estimation&lt;/strong&gt;, is a &lt;a href="https://en.wikipedia.org/wiki/Model_validation" title="Model Validation"&gt;model validation&lt;/a&gt; technique for assessing how the results of a statistical analysis will generalize to an independent data set. It is mainly used in settings where the goal is prediction, and one wants to estimate how accurately a predictive model will perform in practice. In a prediction problem, a model is usually given a dataset of known data on which training is run (training dataset), and a dataset of unknown data (or first seen data) against which the model is tested (testing dataset).[4] The goal of cross validation is to define a dataset to "test" the model in the training phase (i.e., the validation dataset), in order to limit problems like overfitting, give an insight on how the model will generalize to an independent dataset (i.e., an unknown dataset, for instance from a real problem), etc.&lt;/p&gt;
&lt;p&gt;One round of cross-validation involves partitioning a sample of data into complementary subsets, performing the analysis on one subset (called the training set), and validating the analysis on the other subset (called the validation set or testing set). To reduce variability, multiple rounds of cross-validation are performed using different partitions, and the validation results are averaged over the rounds.&lt;/p&gt;
&lt;p&gt;One of the main reasons for using cross-validation instead of using the conventional validation (e.g. partitioning the data set into two sets of 70% for training and 30% for test) is that there is not enough data available to partition it into separate training and test sets without losing significant modelling or testing capability. In these cases, a fair way to properly estimate model prediction performance is to use cross-validation as a powerful general technique.    &lt;/p&gt;
&lt;p&gt;In summary, cross-validation combines (averages) measures of fit (prediction error) to derive a more accurate estimate of model prediction performance.    &lt;/p&gt;
&lt;h3&gt;Common types of cross-validation&lt;/h3&gt;
&lt;p&gt;Two types of cross-validation can be distinguished, exhaustive and non-exhaustive cross-validation.&lt;/p&gt;
&lt;h4&gt;Exhaustive cross-validation&lt;/h4&gt;
&lt;p&gt;Exhaustive cross-validation methods are cross-validation methods which learn and test on all possible ways to divide the original sample into a training and a validation set.&lt;/p&gt;
&lt;h5&gt;Leave-p-out cross-validation&lt;/h5&gt;
&lt;p&gt;Leave-p-out cross-validation (LpO CV) involves using p observations as the validation set and the remaining observations as the training set. This is repeated on all ways to cut the original sample on a validation set of p observations and a training set.&lt;/p&gt;
&lt;p&gt;LpO cross-validation requires training and validating the model \( C_{n}^{p} \) \( C_{n}^{p} \) times, where n is the number of observations in the original sample, and where \( C_{n}^{p} \) is the &lt;a href="https://en.wikipedia.org/wiki/Binomial_coefficient" title="Binomial Coefficient"&gt;binomial coefficient&lt;/a&gt;. For \( p \) &amp;gt; 1 and for even moderately large \( n \), LpO CV can become computationally infeasible. For example, with \( n \) = 100 and \( p \) = 30 = 30 percent of 100 (as suggested above), \( C_{100}^{30} \approx 3\times 10^{25} \).  &lt;/p&gt;
&lt;h5&gt;Leave-one-out cross-validation&lt;/h5&gt;
&lt;p&gt;Leave-one-out cross-validation (LOOCV) is a particular case of leave-p-out cross-validation with \( p \) = 1. The process looks similar to &lt;a href="https://en.wikipedia.org/wiki/Jackknife_resampling" title="Jackknife Resampling"&gt;jackknife&lt;/a&gt;, however with cross-validation you compute a statistic on the left-out sample(s), while with jackknifing you compute a statistic from the kept samples only.&lt;/p&gt;
&lt;p&gt;LOO cross-validation does not have the same problem of excessive compute time as general LpO cross-validation because \( C_{n}^{1}=n \).&lt;/p&gt;
&lt;h4&gt;Non-exhaustive cross-validation&lt;/h4&gt;
&lt;p&gt;Non-exhaustive cross validation methods do not compute all ways of splitting the original sample. Those methods are approximations of leave-p-out cross-validation.&lt;/p&gt;
&lt;h5&gt;k-fold cross-validation&lt;/h5&gt;
&lt;p&gt;In k-fold cross-validation, the original sample is randomly partitioned into k equal sized subsamples. Of the \( k \) subsamples, a single subsample is retained as the validation data for testing the model, and the remaining \( k \) − 1 subsamples are used as training data. The cross-validation process is then repeated \( k \) times (the folds), with each of the k subsamples used exactly once as the validation data. The \( k \) results from the folds can then be averaged to produce a single estimation. The advantage of this method over repeated random sub-sampling (see below) is that all observations are used for both training and validation, and each observation is used for validation exactly once. 10-fold cross-validation is commonly used, but in general k remains an unfixed parameter.&lt;/p&gt;
&lt;p&gt;For example, setting \( k \) = 2 results in 2-fold cross-validation. In 2-fold cross-validation, we randomly shuffle the dataset into two sets \( d_0 \) and \( d_1 \), so that both sets are equal size (this is usually implemented by shuffling the data array and then splitting it in two). We then train on \( d_0 \) and test on \( d_1 \), followed by training on \( d_1 \) and testing on \( d_0 \).&lt;/p&gt;
&lt;p&gt;When \( k \) = \( n \) (the number of observations), the k-fold cross-validation is exactly the leave-one-out cross-validation.&lt;/p&gt;
&lt;p&gt;In stratified k-fold cross-validation, the folds are selected so that the mean response value is approximately equal in all the folds. In the case of a dichotomous classification, this means that each fold contains roughly the same proportions of the two types of class labels.&lt;/p&gt;
&lt;h5&gt;Holdout method&lt;/h5&gt;
&lt;p&gt;In the holdout method, we randomly assign data points to two sets \( d_0 \) and \( d_1 \), usually called the training set and the test set, respectively. The size of each of the sets is arbitrary although typically the test set is smaller than the training set. We then train on \( d_0 \) and test on \( d_1 \).&lt;/p&gt;
&lt;p&gt;In typical cross-validation, multiple runs are aggregated together; in contrast, the holdout method, in isolation, involves a single run. While the holdout method can be framed as "the simplest kind of cross-validation", many sources instead classify holdout as a type of simple validation, rather than a simple or degenerate form of cross-validation.&lt;/p&gt;
&lt;h5&gt;Repeated random sub-sampling validation&lt;/h5&gt;
&lt;p&gt;This method, also known as Monte Carlo cross-validation, randomly splits the dataset into training and validation data. For each such split, the model is fit to the training data, and predictive accuracy is assessed using the validation data. The results are then averaged over the splits. The advantage of this method (over k-fold cross validation) is that the proportion of the training/validation split is not dependent on the number of iterations (folds). The disadvantage of this method is that some observations may never be selected in the validation subsample, whereas others may be selected more than once. In other words, validation subsets may overlap. This method also exhibits Monte Carlo variation, meaning that the results will vary if the analysis is repeated with different random splits.&lt;/p&gt;
&lt;p&gt;As the number of random splits approaches infinity, the result of repeated random sub-sampling validation tends towards that of leave-p-out cross-validation.&lt;/p&gt;
&lt;p&gt;In a stratified variant of this approach, the random samples are generated in such a way that the mean response value (i.e. the dependent variable in the regression) is equal in the training and testing sets. This is particularly useful if the responses are dichotomous with an unbalanced representation of the two response values in the data.&lt;/p&gt;&lt;/div&gt;</description><guid>https://chowy1026.github.io/course-notes/machine-learning/13-validation/</guid><pubDate>Wed, 19 Apr 2017 23:04:10 GMT</pubDate></item><item><title>Principle Component Analysis</title><link>https://chowy1026.github.io/course-notes/machine-learning/12-pca/</link><dc:creator>cHoWy</dc:creator><description>&lt;div&gt;&lt;p&gt;Principal component analysis (PCA) is a statistical procedure that uses an &lt;a href="https://en.wikipedia.org/wiki/Orthogonal_transformation" title="Orthogonal Transformation"&gt;orthogonal transformation&lt;/a&gt; to convert a set of observations of possibly correlated variables into a set of values of linearly uncorrelated variables called principal components (or sometimes, principal modes of variation). The number of principal components is less than or equal to the smaller of the number of original variables or the number of observations. This transformation is defined in such a way that the first principal component has the largest possible variance (that is, accounts for as much of the variability in the data as possible), and each succeeding component in turn has the highest variance possible under the constraint that it is &lt;a href="https://en.wikipedia.org/wiki/Orthogonal" title="Orthogonal"&gt;orthogonal&lt;/a&gt; to the preceding components. The resulting vectors are an uncorrelated &lt;a href="https://en.wikipedia.org/wiki/Orthogonal_basis_set" title="Orthogonal Basis Set"&gt;orthogonal basis set&lt;/a&gt;. PCA is sensitive to the relative scaling of the original variables.&lt;/p&gt;
&lt;p&gt;PCA is mostly used as a tool in &lt;a href="https://en.wikipedia.org/wiki/Exploratory_data_analysis" title="Exploratory Data Analysis"&gt;exploratory data analysis&lt;/a&gt; and for making &lt;a href="https://en.wikipedia.org/wiki/Predictive_modeling" title="Predictive Model"&gt;predictive models&lt;/a&gt;. PCA can be done by &lt;a href="https://en.wikipedia.org/wiki/Eigendecomposition_of_a_matrix" title="Eigenvalue Decomposition"&gt;eigenvalue decomposition&lt;/a&gt; of a data &lt;a href="https://en.wikipedia.org/wiki/Covariance" title="Covariance"&gt;covariance&lt;/a&gt; (or &lt;a href="https://en.wikipedia.org/wiki/Correlation" title="Correlation"&gt;correlation&lt;/a&gt;) matrix or &lt;a href="https://en.wikipedia.org/wiki/Singular_value_decomposition" title="Singular Value Decomposition"&gt;singular value decomposition&lt;/a&gt; of a &lt;a href="https://en.wikipedia.org/wiki/Data_matrix_(multivariate_statistics)" title="Data Matrix"&gt;data matrix&lt;/a&gt;, usually after mean centering (and normalizing or using Z-scores) the data matrix for each attribute. The results of a PCA are usually discussed in terms of component scores, sometimes called factor scores (the transformed variable values corresponding to a particular data point), and loadings (the weight by which each standardized original variable should be multiplied to get the component score).&lt;/p&gt;
&lt;p&gt;PCA is the simplest of the true &lt;a href="https://en.wikipedia.org/wiki/Eigenvectors" title="Eigenvectors"&gt;eigenvector&lt;/a&gt;-based multivariate analyses. Often, its operation can be thought of as revealing the internal structure of the data in a way that best explains the variance in the data. If a multivariate dataset is visualised as a set of coordinates in a high-dimensional data space (1 axis per variable), PCA can supply the user with a lower-dimensional picture, a projection of this object when viewed from its most informative viewpoint. This is done by using only the first few principal components so that the dimensionality of the transformed data is reduced.&lt;/p&gt;
&lt;p&gt;PCA is closely related to &lt;a href="https://en.wikipedia.org/wiki/Factor_analysis" title="Factor Analysis"&gt;factor analysis&lt;/a&gt;. Factor analysis typically incorporates more domain specific assumptions about the underlying structure and solves eigenvectors of a slightly different matrix.&lt;/p&gt;
&lt;p&gt;PCA is also related to &lt;a href="https://en.wikipedia.org/wiki/Canonical_correlation" title="Canonical Correlation"&gt;canonical correlation analysis&lt;/a&gt; (CCA). CCA defines coordinate systems that optimally describe the cross-covariance between two datasets while PCA defines a new &lt;a href="https://en.wikipedia.org/wiki/Orthogonal_coordinate_system" title="Orthogonal Coordinate System"&gt;orthogonal coordinate system&lt;/a&gt; that optimally describes variance in a single dataset.&lt;/p&gt;&lt;/div&gt;</description><guid>https://chowy1026.github.io/course-notes/machine-learning/12-pca/</guid><pubDate>Wed, 19 Apr 2017 23:00:11 GMT</pubDate></item><item><title>Feature Selection</title><link>https://chowy1026.github.io/course-notes/machine-learning/11-feature_selection/</link><dc:creator>cHoWy</dc:creator><description>&lt;div&gt;&lt;p&gt;In machine learning and statistics, &lt;strong&gt;feature selection&lt;/strong&gt;, also known as &lt;strong&gt;variable selection&lt;/strong&gt;, &lt;strong&gt;attribute selection&lt;/strong&gt; or &lt;strong&gt;variable subset selection&lt;/strong&gt;, is the process of selecting a subset of relevant features (variables, predictors) for use in model construction. Feature selection techniques are used for four reasons:      &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;simplification of models to make them easier to interpret by researchers/users,     &lt;/li&gt;
&lt;li&gt;shorter training times,      &lt;/li&gt;
&lt;li&gt;to avoid the &lt;a href="https://en.wikipedia.org/wiki/Curse_of_dimensionality" title="Curse of Dimensionality"&gt;curse of dimensionality&lt;/a&gt;,      &lt;/li&gt;
&lt;li&gt;enhanced generalization by reducing overfitting (formally, reduction of variance)      &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The central premise when using a feature selection technique is that the data contains many features that are either &lt;em&gt;redundant&lt;/em&gt; or &lt;em&gt;irrelevant&lt;/em&gt;, and can thus be removed without incurring much loss of information. &lt;em&gt;Redundant&lt;/em&gt; or &lt;em&gt;irrelevant&lt;/em&gt; features are two distinct notions, since one relevant feature may be redundant in the presence of another relevant feature with which it is strongly correlated.&lt;/p&gt;
&lt;p&gt;Feature selection techniques should be distinguished from &lt;a href="https://en.wikipedia.org/wiki/Feature_extraction" title="Feature Extraction"&gt;feature extraction&lt;/a&gt;. Feature extraction creates new features from functions of the original features, whereas feature selection returns a subset of the features. Feature selection techniques are often used in domains where there are many features and comparatively few samples (or data points). Archetypal cases for the application of feature selection include the analysis of written texts and DNA microarray data, where there are many thousands of features, and a few tens to hundreds of samples.&lt;/p&gt;
&lt;h3&gt;Introduction&lt;/h3&gt;
&lt;p&gt;A feature selection algorithm can be seen as the combination of a search technique for proposing new feature subsets, along with an evaluation measure which scores the different feature subsets. The simplest algorithm is to test each possible subset of features finding the one which minimizes the error rate. This is an exhaustive search of the space, and is computationally intractable for all but the smallest of feature sets. The choice of evaluation metric heavily influences the algorithm, and it is these evaluation metrics which distinguish between the three main categories of feature selection algorithms: wrappers, filters and embedded methods.     &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Wrapper methods use a predictive model to score feature subsets. Each new subset is used to train a model, which is tested on a hold-out set. Counting the number of mistakes made on that hold-out set (the error rate of the model) gives the score for that subset. As wrapper methods train a new model for each subset, they are very computationally intensive, but usually provide the best performing feature set for that particular type of model.      &lt;/li&gt;
&lt;li&gt;Filter methods use a proxy measure instead of the error rate to score a feature subset. This measure is chosen to be fast to compute, while still capturing the usefulness of the feature set. Common measures include the &lt;a href="https://en.wikipedia.org/wiki/Mutual_information" title="Mutual Information"&gt;mutual information&lt;/a&gt;, the &lt;a href="https://en.wikipedia.org/wiki/Pointwise_mutual_information" title="Pointwise Mutual Information"&gt;pointwise mutual information&lt;/a&gt;, &lt;a href="https://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient" title="Pearson Product Moment Correlation Coefficient"&gt;Pearson product-moment correlation coefficient&lt;/a&gt;, inter/intra class distance or the scores of &lt;a href="https://en.wikipedia.org/wiki/Statistical_hypothesis_testing" title="Significance Test"&gt;significance tests&lt;/a&gt; for each class/feature combinations.  Filters are usually less computationally intensive than wrappers, but they produce a feature set which is not tuned to a specific type of predictive model. This lack of tuning means a feature set from a filter is more general than the set from a wrapper, usually giving lower prediction performance than a wrapper. However the feature set doesn't contain the assumptions of a prediction model, and so is more useful for exposing the relationships between the features. Many filters provide a feature ranking rather than an explicit best feature subset, and the cut off point in the ranking is chosen via &lt;a href="https://en.wikipedia.org/wiki/Cross-validation_(statistics)" title="Cross Validation"&gt;cross-validation&lt;/a&gt;. Filter methods have also been used as a preprocessing step for wrapper methods, allowing a wrapper to be used on larger problems.      &lt;/li&gt;
&lt;li&gt;Embedded methods are a catch-all group of techniques which perform feature selection as part of the model construction process. The exemplar of this approach is the &lt;a href="https://en.wikipedia.org/wiki/Lasso_(statistics)" title="Lasso"&gt;LASSO&lt;/a&gt; method for constructing a linear model, which penalizes the regression coefficients with an L1 penalty, shrinking many of them to zero. Any features which have non-zero regression coefficients are 'selected' by the &lt;a href="https://en.wikipedia.org/wiki/Lasso_(statistics)" title="Lasso"&gt;LASSO&lt;/a&gt; algorithm. Improvements to the &lt;a href="https://en.wikipedia.org/wiki/Lasso_(statistics)" title="Lasso"&gt;LASSO&lt;/a&gt; include Bolasso which bootstraps samples, and FeaLect which scores all the features based on combinatorial analysis of regression coefficients. One other popular approach is the Recursive Feature Elimination algorithm, commonly used with Support Vector Machines to repeatedly construct a model and remove features with low weights. These approaches tend to be between filters and wrappers in terms of computational complexity.       &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In traditional statistics, the most popular form of feature selection is &lt;a href="https://en.wikipedia.org/wiki/Stepwise_regression" title="Stepwise Regression"&gt;stepwise regression&lt;/a&gt;, which is a wrapper technique. It is a &lt;a href="https://en.wikipedia.org/wiki/Greedy_algorithm" title="Greedy Algorithm"&gt;greedy algorithm&lt;/a&gt; that adds the best feature (or deletes the worst feature) at each round. The main control issue is deciding when to stop the algorithm. In machine learning, this is typically done by &lt;a href="https://en.wikipedia.org/wiki/Cross-validation_(statistics)" title="Cross Validation"&gt;cross-validation&lt;/a&gt;. In statistics, some criteria are optimized. This leads to the inherent problem of nesting. More robust methods have been explored, such as &lt;a href="https://en.wikipedia.org/wiki/Branch_and_bound" title="Branch and Bound"&gt;branch and bound&lt;/a&gt; and piecewise linear network.&lt;/p&gt;
&lt;h3&gt;Subset selection&lt;/h3&gt;
&lt;p&gt;Subset selection evaluates a subset of features as a group for suitability. Subset selection algorithms can be broken up into Wrappers, Filters and Embedded. Wrappers use a search algorithm to search through the space of possible features and evaluate each subset by running a model on the subset. Wrappers can be computationally expensive and have a risk of over fitting to the model. Filters are similar to Wrappers in the search approach, but instead of evaluating against a model, a simpler filter is evaluated. Embedded techniques are embedded in and specific to a model.&lt;/p&gt;
&lt;p&gt;Many popular search approaches use &lt;a href="https://en.wikipedia.org/wiki/Hill_climbing" title="Hill Climbing"&gt;greedy hill climbing&lt;/a&gt;, which iteratively evaluates a candidate subset of features, then modifies the subset and evaluates if the new subset is an improvement over the old. Evaluation of the subsets requires a scoring metric that grades a subset of features. Exhaustive search is generally impractical, so at some implementor (or operator) defined stopping point, the subset of features with the highest score discovered up to that point is selected as the satisfactory feature subset. The stopping criterion varies by algorithm; possible criteria include: a subset score exceeds a threshold, a program's maximum allowed run time has been surpassed, etc.&lt;/p&gt;
&lt;p&gt;Alternative search-based techniques are based on targeted projection pursuit which finds low-dimensional projections of the data that score highly: the features that have the largest projections in the lower-dimensional space are then selected.&lt;/p&gt;
&lt;p&gt;Search approaches include:       &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Exhaustive    &lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Best-first_search" title="Best First"&gt;Best first&lt;/a&gt;       &lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Simulated_annealing" title="Simulated Annealing"&gt;Simulated annealing&lt;/a&gt;       &lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Genetic_algorithm" title="Genetic Algorithm"&gt;Genetic algorithm&lt;/a&gt;       &lt;/li&gt;
&lt;li&gt;Greedy forward selection        &lt;/li&gt;
&lt;li&gt;Greedy backward elimination              &lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Particle_swarm_optimization" title="Particle Swarm Optimization"&gt;Particle swarm optimization&lt;/a&gt;         &lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Targeted_projection_pursuit" title="Targeted Projection Pursuit"&gt;Targeted projection pursuit&lt;/a&gt;        &lt;/li&gt;
&lt;li&gt;Scatter Search        &lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Variable_Neighborhood_Search" title="Variable Neighborhood Search"&gt;Variable Neighborhood Search&lt;/a&gt;      &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Two popular filter metrics for classification problems are &lt;a href="https://en.wikipedia.org/wiki/Correlation" title="Correlation"&gt;correlation&lt;/a&gt; and &lt;a href="https://en.wikipedia.org/wiki/Mutual_information" title="Mutual Information"&gt;mutual information&lt;/a&gt;, although neither are true metrics or 'distance measures' in the mathematical sense, since they fail to obey the triangle inequality and thus do not compute any actual 'distance' – they should rather be regarded as 'scores'. These scores are computed between a candidate feature (or set of features) and the desired output category. There are, however, true metrics that are a simple function of the mutual information;[15] see here.&lt;/p&gt;
&lt;p&gt;Other available filter metrics include:      &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Class separability       &lt;ul&gt;
&lt;li&gt;Error probability      &lt;/li&gt;
&lt;li&gt;Inter-class distance      &lt;/li&gt;
&lt;li&gt;Probabilistic distance      &lt;/li&gt;
&lt;li&gt;Entropy      &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Consistency-based feature selection      &lt;/li&gt;
&lt;li&gt;Correlation-based feature selection      &lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</description><guid>https://chowy1026.github.io/course-notes/machine-learning/11-feature_selection/</guid><pubDate>Wed, 19 Apr 2017 22:59:28 GMT</pubDate></item><item><title>Text Learning</title><link>https://chowy1026.github.io/course-notes/machine-learning/10-text_learning/</link><dc:creator>cHoWy</dc:creator><description>&lt;p&gt;Write your post here.&lt;/p&gt;</description><guid>https://chowy1026.github.io/course-notes/machine-learning/10-text_learning/</guid><pubDate>Wed, 19 Apr 2017 22:54:29 GMT</pubDate></item><item><title>Feature Scaling</title><link>https://chowy1026.github.io/course-notes/machine-learning/09-feature_scaling/</link><dc:creator>cHoWy</dc:creator><description>&lt;div&gt;&lt;h3&gt;Introduction&lt;/h3&gt;
&lt;p&gt;Feature scaling is a method used to standardize the range of independent variables or features of data. In &lt;a href="https://en.wikipedia.org/wiki/Data_processing" title="Data Processing"&gt;data processing&lt;/a&gt;, it is also known as data normalization and is generally performed during the data preprocessing step.&lt;/p&gt;
&lt;p&gt;Since the range of values of raw data varies widely, in some &lt;a href="https://en.wikipedia.org/wiki/Machine_learning" title="Machine Learning"&gt;machine learning&lt;/a&gt; algorithms, objective functions will not work properly without &lt;a href="https://en.wikipedia.org/wiki/Normalization_(statistics)" title="Normalization"&gt;normalization&lt;/a&gt;. For example, the majority of &lt;a href="https://en.wikipedia.org/wiki/Statistical_classification" title="Classifiers"&gt;classifiers&lt;/a&gt; calculate the distance between two points by the &lt;a href="https://en.wikipedia.org/wiki/Euclidean_distance" title="Euclidean Distance"&gt;Euclidean distance&lt;/a&gt;. If one of the features has a broad range of values, the distance will be governed by this particular feature. Therefore, the range of all features should be normalized so that each feature contributes approximately proportionately to the final distance.&lt;/p&gt;
&lt;p&gt;Another reason why feature scaling is applied is that &lt;a href="https://en.wikipedia.org/wiki/Gradient_descent" title="Gradient Descent"&gt;gradient descent&lt;/a&gt; converges much faster with feature scaling than without it.&lt;/p&gt;
&lt;h3&gt;Methods&lt;/h3&gt;
&lt;h4&gt;Rescaling&lt;/h4&gt;
&lt;p&gt;The simplest method is rescaling the range of features to scale the range in [0, 1] or [−1, 1]. Selecting the target range depends on the nature of the data. The general formula is given as:&lt;/p&gt;
&lt;p&gt;\( x' = \frac{x- \text{min}(x)} {{\text{max}}(x)-{\text{min}}(x)} \)&lt;/p&gt;
&lt;p&gt;where \(  x \) is an original value, \( x' \) is the normalized value. For example, suppose that we have the students' weight data, and the students' weights span [160 pounds, 200 pounds]. To rescale this data, we first subtract 160 from each student's weight and divide the result by 40 (the difference between the maximum and minimum weights).&lt;/p&gt;
&lt;h4&gt;Standardization&lt;/h4&gt;
&lt;p&gt;In machine learning, we can handle various types of data, e.g. audio signals and pixel values for image data, and this data can include multiple &lt;a href="https://en.wikipedia.org/wiki/Dimensions" title="Dimensions"&gt;dimensions&lt;/a&gt;. Feature standardization makes the values of each feature in the data have zero-mean (when subtracting the mean in the numerator) and unit-variance. This method is widely used for normalization in many machine learning algorithms (e.g., &lt;a href="https://en.wikipedia.org/wiki/Support_vector_machine" title="Support Vector Machine"&gt;support vector machines&lt;/a&gt;, &lt;a href="https://en.wikipedia.org/wiki/Logistic_regression" title="Logistic Regression"&gt;logistic regression&lt;/a&gt;, and &lt;a href="https://en.wikipedia.org/wiki/Neural_network" title="Neural Network"&gt;neural networks&lt;/a&gt;). This is typically done by calculating &lt;a href="https://en.wikipedia.org/wiki/Standard_score" title="Standard Score"&gt;standard scores&lt;/a&gt;. The general method of calculation is to determine the distribution mean and standard deviation for each feature. Next we subtract the mean from each feature. Then we divide the values (mean is already subtracted) of each feature by its standard deviation.&lt;/p&gt;
&lt;p&gt;\( x'= \frac{x-{\bar {x}}}{\sigma } \)&lt;/p&gt;
&lt;p&gt;Where \(  x \) is the original feature vector, \( \bar {x} \) is the mean of that feature vector, and \( \sigma \)  is its standard deviation.&lt;/p&gt;
&lt;h4&gt;Scaling to unit length&lt;/h4&gt;
&lt;p&gt;Another option that is widely used in machine-learning is to scale the components of a feature vector such that the complete vector has length one. This usually means dividing each component by the &lt;a href="https://en.wikipedia.org/wiki/Euclidean_length" title="Euclidean Length"&gt;Euclidean length&lt;/a&gt; of the vector. In some applications (e.g. Histogram features) it can be more practical to use the L1 norm (i.e. Manhattan Distance, City-Block Length or &lt;a href="https://en.wikipedia.org/wiki/Taxicab_Geometry" title="Taxicab Geometry"&gt;Taxicab Geometry&lt;/a&gt;) of the feature vector:&lt;/p&gt;
&lt;p&gt;\(  x'= \frac {x}{||x||} \)
This is especially important if in the following learning steps the Scalar Metric is used as a distance measure.&lt;/p&gt;&lt;/div&gt;</description><guid>https://chowy1026.github.io/course-notes/machine-learning/09-feature_scaling/</guid><pubDate>Wed, 19 Apr 2017 22:53:53 GMT</pubDate></item><item><title>Unsupervised Learning - Clustering</title><link>https://chowy1026.github.io/course-notes/machine-learning/08-unsupervised_learning-clustering/</link><dc:creator>cHoWy</dc:creator><description>&lt;div&gt;&lt;h3&gt;Unsupervised Learning&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Unsupervised machine learning&lt;/strong&gt; is the machine learning task of inferring a function to describe hidden structure from "unlabeled" data (a classification or categorization is not included in the observations). Since the examples given to the learner are unlabeled, there is no evaluation of the accuracy of the structure that is output by the relevant algorithm—which is one way of distinguishing &lt;a href="https://en.wikipedia.org/wiki/Unsupervised_learning" title="Unsupervised Learning"&gt;unsupervised learning&lt;/a&gt; from &lt;a href="https://en.wikipedia.org/wiki/Supervised_learning" title="Supervised Learning"&gt;supervised learning&lt;/a&gt; and &lt;a href="https://en.wikipedia.org/wiki/Reinforcement_learning" title="Reinforced Learning"&gt;reinforcement learning&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A central case of unsupervised learning is the problem of &lt;a href="https://en.wikipedia.org/wiki/Density_estimation" title="Density Estimation"&gt;density estimation&lt;/a&gt; in statistics, though unsupervised learning encompasses many other problems (and solutions) involving summarizing and explaining key features of the data.&lt;/p&gt;
&lt;p&gt;Approaches to unsupervised learning include:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://en.wikipedia.org/wiki/Data_clustering" title="Data Clustering"&gt;Clustering&lt;/a&gt;&lt;/strong&gt;    &lt;br&gt;
- &lt;a href="https://en.wikipedia.org/wiki/K-means" title="K Means"&gt;k-means&lt;/a&gt;    &lt;br&gt;
- &lt;a href="https://en.wikipedia.org/wiki/Mixture_models" title="Mixture Models"&gt;mixture models&lt;/a&gt;    &lt;br&gt;
- &lt;a href="https://en.wikipedia.org/wiki/Hierarchical_clustering" title="Hierachical Clustering"&gt;hierarchical clustering&lt;/a&gt;      &lt;br&gt;
&lt;strong&gt;&lt;a href="https://en.wikipedia.org/wiki/Anomaly_detection" title="Anomaly Detection"&gt;Anomaly detection&lt;/a&gt;&lt;/strong&gt;     &lt;br&gt;
&lt;strong&gt;&lt;a href="https://en.wikipedia.org/wiki/Artificial_neural_network" title="Neural Network"&gt;Neural Networks&lt;/a&gt;&lt;/strong&gt;   &lt;br&gt;
- &lt;a href="https://en.wikipedia.org/wiki/Hebbian_Learning" title="Hebbian Learning"&gt;Hebbian Learning&lt;/a&gt;  &lt;br&gt;
- &lt;a href="https://en.wikipedia.org/wiki/Generative_Adversarial_Networks" title="Generative Adversarial Networks"&gt;Generative Adversarial Networks&lt;/a&gt;  &lt;br&gt;
&lt;strong&gt;Approaches for learning &lt;a href="https://en.wikipedia.org/wiki/Latent_variable_model" title="Latent Variable Model"&gt;latent variable models&lt;/a&gt;&lt;/strong&gt; such as          &lt;br&gt;
- &lt;a href="https://en.wikipedia.org/wiki/Expectation%E2%80%93maximization_algorithm" title="Expectation Maximization Algorithm"&gt;Expectation-Maximization Algorithm&lt;/a&gt; (EM)
- &lt;a href="https://en.wikipedia.org/wiki/Method_of_moments_(statistics)" title="Method of Moments"&gt;Method of moments&lt;/a&gt;
- &lt;a href="https://en.wikipedia.org/wiki/Blind_signal_separation" title="Blind Signal Separation"&gt;Blind signal separation&lt;/a&gt; techniques, e.g.,
    - &lt;a href="https://en.wikipedia.org/wiki/Principal_component_analysis" title="Principal Component Analysis (PCA)"&gt;Principal component analysis&lt;/a&gt;,     &lt;br&gt;
    - &lt;a href="https://en.wikipedia.org/wiki/Independent_component_analysis" title="Independent Component Analysis"&gt;Independent component analysis&lt;/a&gt;,     &lt;br&gt;
    - &lt;a href="https://en.wikipedia.org/wiki/Non-negative_matrix_factorization" title="Non-Negative Matrix Factorization"&gt;Non-negative matrix factorization&lt;/a&gt;,     &lt;br&gt;
    - &lt;a href="https://en.wikipedia.org/wiki/Singular_value_decomposition" title="Singular Value Decomposition"&gt;Singular value decomposition&lt;/a&gt;.        &lt;/p&gt;
&lt;h3&gt;Clustering&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Cluster analysis&lt;/strong&gt; or &lt;strong&gt;Clustering&lt;/strong&gt; is the task of grouping a set of objects in such a way that objects in the same group (called a cluster) are more similar (in some sense or another) to each other than to those in other groups (clusters). It is a main task of exploratory &lt;a href="https://en.wikipedia.org/wiki/Data_mining" title="Data Mining"&gt;data mining&lt;/a&gt;, and a common technique for statistical data analysis, used in many fields, including &lt;a href="https://en.wikipedia.org/wiki/Machine_learning" title="Machine Learning"&gt;machine learning&lt;/a&gt;, &lt;a href="https://en.wikipedia.org/wiki/Pattern_recognition" title="Pattern Recognition"&gt;pattern recognition&lt;/a&gt;, &lt;a href="https://en.wikipedia.org/wiki/Image_analysis" title="Image Analysis"&gt;image analysis&lt;/a&gt;, &lt;a href="https://en.wikipedia.org/wiki/Information_retrieval" title="Information Retrieval"&gt;information retrieval&lt;/a&gt;, &lt;a href="https://en.wikipedia.org/wiki/Bioinformatics" title="Bio-Informatics"&gt;bioinformatics&lt;/a&gt;, &lt;a href="https://en.wikipedia.org/wiki/Data_compression" title="Data Compression"&gt;data compression&lt;/a&gt;, and &lt;a href="https://en.wikipedia.org/wiki/Computer_graphics" title="Computer Graphics"&gt;computer graphics&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Cluster analysis itself is not one specific algorithm, but the general task to be solved. It can be achieved by various algorithms that differ significantly in their notion of what constitutes a cluster and how to efficiently find them. Popular notions of clusters include groups with small distances among the cluster members, dense areas of the data space, intervals or particular statistical distributions. Clustering can therefore be formulated as a &lt;a href="https://en.wikipedia.org/wiki/Multi-objective_optimization" title="Multi-Objective Optimization"&gt;multi-objective optimization&lt;/a&gt; problem. The appropriate clustering algorithm and parameter settings (including values such as the distance function to use, a density threshold or the number of expected clusters) depend on the individual data set and intended use of the results. Cluster analysis as such is not an automatic task, but an iterative process of knowledge discovery or interactive multi-objective optimization that involves trial and failure. It is often necessary to modify data preprocessing and model parameters until the result achieves the desired properties.&lt;/p&gt;
&lt;p&gt;Besides the term clustering, there are a number of terms with similar meanings, including &lt;em&gt;automatic classification&lt;/em&gt;, &lt;em&gt;numerical taxonomy&lt;/em&gt;, &lt;em&gt;botryology&lt;/em&gt; (from Greek βότρυς "grape") and typological analysis. The subtle differences are often in the usage of the results: while in data mining, the resulting groups are the matter of interest, in automatic classification the resulting discriminative power is of interest.&lt;/p&gt;
&lt;p&gt;The notion of a "cluster" cannot be precisely defined, which is one of the reasons why there are so many clustering algorithms. There is a common denominator: a group of data objects. However, different researchers employ different cluster models, and for each of these cluster models again different algorithms can be given. The notion of a cluster, as found by different algorithms, varies significantly in its properties. Understanding these "cluster models" is key to understanding the differences between the various algorithms.&lt;/p&gt;
&lt;p&gt;Typical cluster models include:          &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Connectivity models: for example, &lt;a href="https://en.wikipedia.org/wiki/Hierarchical_clustering" title="Hierachical Clustering"&gt;hierarchical clustering&lt;/a&gt; builds models based on distance connectivity.    &lt;/li&gt;
&lt;li&gt;Centroid models: for example, the &lt;a href="https://en.wikipedia.org/wiki/K-means_algorithm" title="K Means Algorithm"&gt;k-means algorithm&lt;/a&gt; represents each cluster by a single mean vector.      &lt;/li&gt;
&lt;li&gt;Distribution models: clusters are modeled using statistical distributions, such as &lt;a href="https://en.wikipedia.org/wiki/Multivariate_normal_distribution" title="Multivariate Normal Distribution"&gt;multivariate normal distributions&lt;/a&gt; used by the &lt;a href="https://en.wikipedia.org/wiki/Expectation%E2%80%93maximization_algorithm" title="Expectation Maximization Algorithm"&gt;Expectation-Maximization Algorithm&lt;/a&gt;.         &lt;/li&gt;
&lt;li&gt;Density models: for example, DBSCAN and OPTICS defines clusters as connected dense regions in the data space.        &lt;/li&gt;
&lt;li&gt;Subspace models: in Biclustering (also known as Co-clustering or two-mode-clustering), clusters are modeled with both cluster members and relevant attributes.       &lt;/li&gt;
&lt;li&gt;Group models: some algorithms do not provide a refined model for their results and just provide the grouping information.         &lt;/li&gt;
&lt;li&gt;Graph-based models: a clique, that is, a subset of nodes in a graph such that every two nodes in the subset are connected by an edge can be considered as a prototypical form of cluster. Relaxations of the complete connectivity requirement (a fraction of the edges can be missing) are known as quasi-cliques, as in the HCS clustering algorithm.        &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A "clustering" is essentially a set of such clusters, usually containing all objects in the data set. Additionally, it may specify the relationship of the clusters to each other, for example, a hierarchy of clusters embedded in each other. Clusterings can be roughly distinguished as:         &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hard clustering: each object belongs to a cluster or not         &lt;/li&gt;
&lt;li&gt;Soft clustering (also: &lt;a href="https://en.wikipedia.org/wiki/Fuzzy_clustering" title="Fuzzy Clustering"&gt;fuzzy clustering&lt;/a&gt;): each object belongs to each cluster to a certain degree (for example, a likelihood of belonging to the cluster)       &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There are also finer distinctions possible, for example:        &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Strict partitioning clustering: each object belongs to exactly one cluster      &lt;/li&gt;
&lt;li&gt;Strict partitioning clustering with outliers: objects can also belong to no cluster, and are considered outliers       &lt;/li&gt;
&lt;li&gt;Overlapping clustering (also: alternative clustering, multi-view clustering): objects may belong to more than one cluster; usually involving hard clusters        &lt;/li&gt;
&lt;li&gt;Hierarchical clustering: objects that belong to a child cluster also belong to the parent cluster        &lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Subspace_clustering" title="Subspace Clustering"&gt;Subspace clustering&lt;/a&gt;: while an overlapping clustering, within a uniquely defined subspace, clusters are not expected to overlap        &lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</description><guid>https://chowy1026.github.io/course-notes/machine-learning/08-unsupervised_learning-clustering/</guid><pubDate>Wed, 19 Apr 2017 22:53:05 GMT</pubDate></item><item><title>Outliers</title><link>https://chowy1026.github.io/course-notes/machine-learning/07-outliers/</link><dc:creator>cHoWy</dc:creator><description>&lt;div&gt;&lt;p&gt;In statistics, an outlier is an observation point that is distant from other observations. An outlier may be due to variability in the measurement or it may indicate experimental error; the latter are sometimes excluded from the data set.&lt;/p&gt;
&lt;p&gt;Outliers can occur by chance in any distribution, but they often indicate either &lt;a href="https://en.wikipedia.org/wiki/Measurement_error" title="Measurement Error"&gt;measurement error&lt;/a&gt; or that the population has a &lt;a href="https://en.wikipedia.org/wiki/Heavy-tailed_distribution" title="Heavy Tailed Distribution"&gt;heavy-tailed distribution&lt;/a&gt;. In the former case one wishes to discard them or use statistics that are robust to outliers, while in the latter case they indicate that the distribution has high skewness and that one should be very cautious in using tools or intuitions that assume a normal distribution. A frequent cause of outliers is a mixture of two distributions, which may be two distinct sub-populations, or may indicate 'correct trial' versus 'measurement error'; this is modeled by a &lt;a href="https://en.wikipedia.org/wiki/Mixture_model" title="Mixture Model"&gt;mixture model&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In most larger samplings of data, some data points will be further away from the sample mean than what is deemed reasonable. This can be due to incidental systematic error or flaws in the theory that generated an assumed family of probability distributions, or it may be that some observations are far from the center of the data. Outlier points can therefore indicate faulty data, erroneous procedures, or areas where a certain theory might not be valid. However, in large samples, a small number of outliers is to be expected (and not due to any anomalous condition).&lt;/p&gt;
&lt;p&gt;Outliers, being the most extreme observations, may include the sample maximum or sample minimum, or both, depending on whether they are extremely high or low. However, the sample maximum and minimum are not always outliers because they may not be unusually far from other observations.&lt;/p&gt;
&lt;p&gt;Naive interpretation of statistics derived from data sets that include outliers may be misleading. For example, if one is calculating the average temperature of 10 objects in a room, and nine of them are between 20 and 25 degrees Celsius, but an oven is at 175 °C, the median of the data will be between 20 and 25 °C but the mean temperature will be between 35.5 and 40 °C. In this case, the median better reflects the temperature of a randomly sampled object (but not the temperature in the room) than the mean; naively interpreting the mean as "a typical sample", equivalent to the median, is incorrect. As illustrated in this case, outliers may indicate data points that belong to a different population than the rest of the sample set.&lt;/p&gt;
&lt;p&gt;Estimators capable of coping with outliers are said to be robust: the median is a robust statistic of central tendency, while the mean is not. However, the mean is generally more precise estimator.&lt;/p&gt;&lt;/div&gt;</description><guid>https://chowy1026.github.io/course-notes/machine-learning/07-outliers/</guid><pubDate>Wed, 19 Apr 2017 22:51:18 GMT</pubDate></item><item><title>Datasets and Questions</title><link>https://chowy1026.github.io/course-notes/machine-learning/05-datasets_and_questions/</link><dc:creator>cHoWy</dc:creator><description>&lt;div&gt;&lt;h3&gt;Accuracy and Training Set Size&lt;/h3&gt;
&lt;p&gt;The larger the training data set the higher to chance of obtaining higher accuracy.  If the training set isn't big enough, accuracy could be low.  However, the accuracy increment by dataset size would plateau off at some point, as adding more data points won't improve accuracy much.  &lt;/p&gt;
&lt;p&gt;In real life, there might be cases where datasets are small in size, and it is not possible to attain more data.  But most data projects, it is always good to start with question like this : how does accuracy change with the number of training events especially if we have the power to go out and obtain more data (data points).  &lt;/p&gt;
&lt;p&gt;Datasets with incomplete information will also lead to low accuracy.  &lt;/p&gt;
&lt;h3&gt;Types of Data&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Numerical      &lt;/li&gt;
&lt;li&gt;Salary Info     &lt;/li&gt;
&lt;li&gt;Number of email sent      &lt;/li&gt;
&lt;li&gt;Categorical     &lt;/li&gt;
&lt;li&gt;Job title      &lt;/li&gt;
&lt;li&gt;Time Series       &lt;/li&gt;
&lt;li&gt;Time Stamp on emails      &lt;/li&gt;
&lt;li&gt;Text      &lt;/li&gt;
&lt;li&gt;Content on emails      &lt;/li&gt;
&lt;li&gt;To/From of emails      &lt;/li&gt;
&lt;li&gt;Other     &lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</description><guid>https://chowy1026.github.io/course-notes/machine-learning/05-datasets_and_questions/</guid><pubDate>Wed, 19 Apr 2017 22:28:08 GMT</pubDate></item><item><title>Supervised Learning - Regression</title><link>https://chowy1026.github.io/course-notes/machine-learning/06-supervised_learning-regression/</link><dc:creator>cHoWy</dc:creator><description>&lt;div&gt;&lt;p&gt;In &lt;a href="https://en.wikipedia.org/wiki/Statistical_model" title="Statistical Model"&gt;statistical modeling&lt;/a&gt;, &lt;strong&gt;regression analysis&lt;/strong&gt; is a statistical process for estimating the relationships among variables. It includes many techniques for modeling and analyzing several variables, when the focus is on the relationship between a &lt;a href="https://en.wikipedia.org/wiki/Dependent_variable" title="Dependent Variable"&gt;dependent variable&lt;/a&gt; and one or more &lt;a href="https://en.wikipedia.org/wiki/Independent_variable" title="Independent Variable"&gt;independent variables&lt;/a&gt; (or 'predictors'). More specifically, regression analysis helps one understand how the typical value of the dependent variable (or 'criterion variable') changes when any one of the independent variables is varied, while the other independent variables are held fixed. Most commonly, regression analysis estimates the &lt;a href="https://en.wikipedia.org/wiki/Conditional_expectation" title="Conditional Expectation"&gt;conditional expectation&lt;/a&gt; of the dependent variable given the independent variables – that is, the &lt;a href="https://en.wikipedia.org/wiki/Average_value" title="Average Value"&gt;average value&lt;/a&gt; of the dependent variable when the independent variables are fixed. Less commonly, the focus is on a &lt;a href="https://en.wikipedia.org/wiki/Quantile" title="Quantile"&gt;quantile&lt;/a&gt;, or other &lt;a href="https://en.wikipedia.org/wiki/Location_parameter" title="Location Parameter"&gt;location parameter&lt;/a&gt; of the conditional distribution of the dependent variable given the independent variables. In all cases, the estimation target is a function of the independent variables called the &lt;strong&gt;regression function&lt;/strong&gt;. In regression analysis, it is also of interest to characterize the variation of the dependent variable around the regression function which can be described by a &lt;a href="https://en.wikipedia.org/wiki/Probability_distribution" title="Probability Distribution"&gt;probability distribution&lt;/a&gt;. A related but distinct approach is necessary condition analysis (NCA), which estimates the maximum (rather than average) value of the dependent variable for a given value of the independent variable (ceiling line rather than central line) in order to identify what value of the independent variable is necessary but not sufficient for a given value of the dependent variable.&lt;/p&gt;
&lt;p&gt;Regression analysis is widely used for &lt;a href="https://en.wikipedia.org/wiki/Prediction" title="Prediction"&gt;prediction&lt;/a&gt; and &lt;a href="https://en.wikipedia.org/wiki/Forecasting" title="Forecasting"&gt;forecasting&lt;/a&gt;, where its use has substantial overlap with the field of machine learning. Regression analysis is also used to understand which among the independent variables are related to the dependent variable, and to explore the forms of these relationships. In restricted circumstances, regression analysis can be used to infer &lt;a href="https://en.wikipedia.org/wiki/Causality" title="Casual Relationships"&gt;causal relationships&lt;/a&gt; between the independent and dependent variables. However this can lead to illusions or false relationships, so caution is advisable;[2] for example, &lt;a href="https://en.wikipedia.org/wiki/Correlation_does_not_imply_causation" title="Correlation is Not Causation"&gt;correlation does not imply causation&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Many techniques for carrying out regression analysis have been developed. Familiar methods such as &lt;a href="https://en.wikipedia.org/wiki/Linear_regression" title="Linear Regression"&gt;linear regression&lt;/a&gt; and &lt;a href="https://en.wikipedia.org/wiki/Ordinary_least_squares" title="Ordinary Least Squares"&gt;ordinary least squares&lt;/a&gt; regression are &lt;a href="https://en.wikipedia.org/wiki/Parametric_statistics" title="Parametric Statistics"&gt;parametric&lt;/a&gt;, in that the regression function is defined in terms of a finite number of unknown parameters that are estimated from the data. &lt;a href="https://en.wikipedia.org/wiki/Nonparametric_regression" title="Non-Parametric Regression"&gt;Nonparametric regression&lt;/a&gt; refers to techniques that allow the regression function to lie in a specified set of functions, which may be infinite-dimensional.&lt;/p&gt;
&lt;p&gt;The performance of regression analysis methods in practice depends on the form of the data generating process, and how it relates to the regression approach being used. Since the true form of the data-generating process is generally not known, regression analysis often depends to some extent on making assumptions about this process. These assumptions are sometimes testable if a sufficient quantity of data is available. Regression models for prediction are often useful even when the assumptions are moderately violated, although they may not perform optimally. However, in many applications, especially with small effects or questions of causality based on observational data, regression methods can give misleading results.&lt;/p&gt;
&lt;p&gt;In a narrower sense, regression may refer specifically to the estimation of continuous response variables, as opposed to the discrete response variables used in &lt;a href="https://en.wikipedia.org/wiki/Statistical_classification" title="Statistical Classification"&gt;classification&lt;/a&gt;. The case of a continuous output variable may be more specifically referred to as &lt;strong&gt;metric regression&lt;/strong&gt; to distinguish it from related problems.&lt;/p&gt;
&lt;h3&gt;Linear Regression&lt;/h3&gt;
&lt;p&gt;In statistics, linear regression is an approach for modeling the relationship between a scalar dependent variable \(y\) and one or more explanatory variables (or independent variables) denoted \(X\). The case of one explanatory variable is called &lt;a href="https://en.wikipedia.org/wiki/Simple_linear_regression" title="Simple Linear Regression"&gt;simple linear regression&lt;/a&gt;. For more than one explanatory variable, the process is called &lt;em&gt;multiple linear regression&lt;/em&gt;. (This term is distinct from &lt;a href="https://en.wikipedia.org/wiki/General_linear_model" title="Multivariate Regression"&gt;multivariate linear regression&lt;/a&gt;, where multiple correlated dependent variables are predicted, rather than a single scalar variable.)&lt;/p&gt;
&lt;p&gt;In linear regression, the relationships are modeled using &lt;a href="https://en.wikipedia.org/wiki/Linear_predictor_function" title="Linear Predictor Function"&gt;linear predictor functions&lt;/a&gt; whose unknown model parameters are &lt;a href="https://en.wikipedia.org/wiki/Estimation_theory" title="Estimation Theory"&gt;estimated&lt;/a&gt; from the data. Such models are called &lt;a href="https://en.wikipedia.org/wiki/Linear_model" title="Linear Model"&gt;linear models&lt;/a&gt;. Most commonly, the &lt;a href="https://en.wikipedia.org/wiki/Conditional_expectation" title="Conditional Expectation"&gt;conditional&lt;/a&gt; mean of \(y\) given the value of \(X\) is assumed to be an &lt;a href="https://en.wikipedia.org/wiki/Affine_transformation" title="Affine Transformation"&gt;affine function&lt;/a&gt; of \(X\); less commonly, the &lt;a href="https://en.wikipedia.org/wiki/Median" title="Median"&gt;median&lt;/a&gt; or some other quantile of the conditional distribution of \(y\) given \(X\) is expressed as a linear function of \(X\). Like all forms of regression analysis, linear regression focuses on the &lt;a href="https://en.wikipedia.org/wiki/Conditional_probability_distribution" title="Conditional Probability Distribution"&gt;conditional probability distribution&lt;/a&gt; of \(y\) given \(X\), rather than on the &lt;a href="https://en.wikipedia.org/wiki/Joint_probability_distribution" title="Joint Probability Distribution"&gt;joint probability distribution&lt;/a&gt; of \(y\) and \(X\), which is the domain of &lt;a href="https://en.wikipedia.org/wiki/Multivariate_analysis" title="Multivariate Analysis"&gt;multivariate analysis&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Linear regression was the first type of regression analysis to be studied rigorously, and to be used extensively in practical applications. This is because models which depend linearly on their unknown parameters are easier to fit than models which are non-linearly related to their parameters and because the statistical properties of the resulting estimators are easier to determine.&lt;/p&gt;
&lt;p&gt;Linear regression has many practical uses. Most applications fall into one of the following two broad categories:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If the goal is prediction, or forecasting, or error reduction, linear regression can be used to fit a predictive model to an observed data set of \(y\) and \(X\) values. After developing such a model, if an additional value of \(X\) is then given without its accompanying value of \(y\), the fitted model can be used to make a prediction of the value of \(y\).         &lt;/li&gt;
&lt;li&gt;Given a variable \(y\) and a number of variables \(X_1, \, \ldots, \, X_p \) that may be related to \(y\), linear regression analysis can be applied to quantify the strength of the relationship between \(y\) and the \(X_j\), to assess which \(X_j\) may have no relationship with \(y\) at all, and to identify which subsets of the \(X_j\) contain redundant information about \(y\).        &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Linear regression models are often fitted using the &lt;a href="https://en.wikipedia.org/wiki/Least_squares" title="Least Square"&gt;least squares&lt;/a&gt; approach, but they may also be fitted in other ways, such as by minimizing the "lack of fit" in some other &lt;a href="https://en.wikipedia.org/wiki/Norm_(mathematics)" title="Mathematical Norm"&gt;norm&lt;/a&gt; (as with &lt;a href="https://en.wikipedia.org/wiki/Least_absolute_deviations" title="Least Absolute Deviation"&gt;least absolute deviations&lt;/a&gt; regression), or by minimizing a penalized version of the least squares &lt;a href="https://en.wikipedia.org/wiki/Loss_function" title="Loss Function"&gt;loss function&lt;/a&gt; as in &lt;a href="https://en.wikipedia.org/wiki/Ridge_regression" title="Ridge Regression"&gt;ridge regression&lt;/a&gt; (L2-norm penalty) and &lt;a href="https://en.wikipedia.org/wiki/Lasso_(statistics)" title="Lasso"&gt;lasso&lt;/a&gt; (L1-norm penalty). Conversely, the least squares approach can be used to fit models that are not linear models. Thus, although the terms "least squares" and "linear model" are closely linked, they are not synonymous.&lt;/p&gt;
&lt;h4&gt;Introduction&lt;/h4&gt;
&lt;p&gt;Given a data set
\(  \left\{y_{i},   \, x_{i1}, \, \ldots, \,   x_{ip}  \right\} _{i=0}^{n} \)
of  \( n \) statistical units, a linear regression model assumes that the relationship between the dependent variable \( y_{i} \) and the &lt;em&gt;p-vector&lt;/em&gt; of regressors \( x_{i} \) is linear. This relationship is modeled through a disturbance term or error variable \( \epsilon_i \)— an unobserved random variable that adds noise to the linear relationship between the dependent variable and regressors.      &lt;/p&gt;
&lt;p&gt;Thus the model takes the form
\[ y_{i} = \beta _{0}1 + \beta _{1}x _{i1} + \cdots + \beta _{p} x _{ip} + \varepsilon _{i} = \mathbf{x} _{i}^{ \top }{\boldsymbol{\beta}} + \varepsilon _{i},\qquad i=1,\ldots ,n, &lt;br&gt;
\]  &lt;/p&gt;
&lt;p&gt;where T denotes the transpose, so that \( \mathbf{x} _{i}^{ \top }{\boldsymbol{\beta}} \) is the inner product between vectors \( \mathbf{x} _{i} \) and \( \boldsymbol{\beta} \).&lt;/p&gt;
&lt;h4&gt;Assumptions&lt;/h4&gt;
&lt;p&gt;Standard linear regression models with standard estimation techniques make a number of assumptions about the predictor variables, the response variables and their relationship. Numerous extensions have been developed that allow each of these assumptions to be relaxed (i.e. reduced to a weaker form), and in some cases eliminated entirely. Some methods are general enough that they can relax multiple assumptions at once, and in other cases this can be achieved by combining different extensions. Generally these extensions make the estimation procedure more complex and time-consuming, and may also require more data in order to produce an equally precise model.       &lt;/p&gt;
&lt;p&gt;The following are the major assumptions made by standard linear regression models with standard estimation techniques (e.g. &lt;a href="https://en.wikipedia.org/wiki/Ordinary_least_squares" title="Ordinary Least Squares"&gt;ordinary least squares&lt;/a&gt;):        &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Weak exogeneity&lt;/strong&gt;. This essentially means that the predictor variables x can be treated as fixed values, rather than &lt;a href="https://en.wikipedia.org/wiki/Random_variable" title="Random Variables"&gt;random variables&lt;/a&gt;. This means, for example, that the predictor variables are assumed to be error-free—that is, not contaminated with measurement errors. Although this assumption is not realistic in many settings, dropping it leads to significantly more difficult &lt;a href="https://en.wikipedia.org/wiki/Errors-in-variables_model" title="Errors in Variable Model"&gt;errors-in-variables models&lt;/a&gt;.      &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Linearity&lt;/strong&gt;. This means that the mean of the response variable is a &lt;a href="https://en.wikipedia.org/wiki/Linear_combination" title="Linear Combination"&gt;linear combination&lt;/a&gt; of the parameters (regression coefficients) and the predictor variables. Note that this assumption is much less restrictive than it may at first seem. Because the predictor variables are treated as fixed values (see above), linearity is really only a restriction on the parameters. The predictor variables themselves can be arbitrarily transformed, and in fact multiple copies of the same underlying predictor variable can be added, each one transformed differently. This trick is used, for example, in &lt;a href="https://en.wikipedia.org/wiki/Polynomial_regression" title="Polynomial Regression"&gt;polynomial regression&lt;/a&gt;, which uses linear regression to fit the response variable as an arbitrary &lt;a href="https://en.wikipedia.org/wiki/Polynomial" title="Polynomial"&gt;polynomial&lt;/a&gt; function (up to a given rank) of a predictor variable. This makes linear regression an extremely powerful inference method. In fact, models such as polynomial regression are often "too powerful", in that they tend to overfit the data. As a result, some kind of regularization must typically be used to prevent unreasonable solutions coming out of the estimation process. Common examples are &lt;a href="https://en.wikipedia.org/wiki/Ridge_regression" title="Ridge Regression"&gt;ridge regression&lt;/a&gt; and &lt;a href="https://en.wikipedia.org/wiki/Lasso_regression" title="Lasso Regression"&gt;lasso regression&lt;/a&gt;. &lt;a href="https://en.wikipedia.org/wiki/Bayesian_linear_regression" title="Bayesian Linear Regression"&gt;Bayesian linear regression&lt;/a&gt; can also be used, which by its nature is more or less immune to the problem of overfitting. (In fact, &lt;a href="https://en.wikipedia.org/wiki/Ridge_regression" title="Ridge Regression"&gt;ridge regression&lt;/a&gt; and &lt;a href="https://en.wikipedia.org/wiki/Lasso_regression" title="Lasso Regression"&gt;lasso regression&lt;/a&gt; can both be viewed as special cases of Bayesian linear regression, with particular types of prior distributions placed on the regression coefficients.)       &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Constant variance&lt;/strong&gt; (a.k.a. &lt;strong&gt;&lt;a href="https://en.wikipedia.org/wiki/Homoscedasticity" title="Homoscedasticity"&gt;homoscedasticity&lt;/a&gt;&lt;/strong&gt;). This means that different response variables have the same variance in their errors, regardless of the values of the predictor variables. In practice this assumption is invalid (i.e. the errors are heteroscedastic) if the response variables can vary over a wide scale. In order to determine for heterogeneous error variance, or when a pattern of residuals violates model assumptions of homoscedasticity (error is equally variable around the 'best-fitting line' for all points of x), it is prudent to look for a "fanning effect" between residual error and predicted values. This is to say there will be a systematic change in the absolute or squared residuals when plotted against the predicting outcome. Error will not be evenly distributed across the regression line. Heteroscedasticity will result in the averaging over of distinguishable variances around the points to get a single variance that is inaccurately representing all the variances of the line. In effect, residuals appear clustered and spread apart on their predicted plots for larger and smaller values for points along the linear regression line, and the mean squared error for the model will be wrong. Typically, for example, a response variable whose mean is large will have a greater variance than one whose mean is small. For example, a given person whose income is predicted to be \$100,000 may easily have an actual income of \$80,000 or \$120,000 (a standard deviation of around \$20,000), while another person with a predicted income of \$10,000 is unlikely to have the same \$20,000 standard deviation, which would imply their actual income would vary anywhere between -\$10,000 and \$30,000. (In fact, as this shows, in many cases—often the same cases where the assumption of normally distributed errors fails—the variance or standard deviation should be predicted to be proportional to the mean, rather than constant.) Simple linear regression estimation methods give less precise parameter estimates and misleading inferential quantities such as standard errors when substantial heteroscedasticity is present. However, various estimation techniques (e.g. &lt;a href="https://en.wikipedia.org/wiki/Weighted_least_squares" title="Weighted Least Squares"&gt;weighted least squares&lt;/a&gt; and &lt;a href="https://en.wikipedia.org/wiki/Heteroscedasticity-consistent_standard_errors" title="Heteroscedasticity Consistent Standard Errors"&gt;heteroscedasticity-consistent standard errors&lt;/a&gt;) can handle heteroscedasticity in a quite general way. Bayesian linear regression techniques can also be used when the variance is assumed to be a function of the mean. It is also possible in some cases to fix the problem by applying a transformation to the response variable (e.g. fit the logarithm of the response variable using a linear regression model, which implies that the response variable has a log-normal distribution rather than a normal distribution).          &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Independence of errors&lt;/strong&gt;. This assumes that the errors of the response variables are uncorrelated with each other. (Actual statistical independence is a stronger condition than mere lack of correlation and is often not needed, although it can be exploited if it is known to hold.) Some methods (e.g. generalized least squares) are capable of handling correlated errors, although they typically require significantly more data unless some sort of regularization is used to bias the model towards assuming uncorrelated errors. Bayesian linear regression is a general way of handling this issue.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Lack of multicollinearity&lt;/strong&gt; in the predictors. For standard least squares estimation methods, the design matrix \( X \) must have full column rank \( p \); otherwise, we have a condition known as &lt;a href="https://en.wikipedia.org/wiki/Multicollinearity" title="Multicollinearity"&gt;multicollinearity&lt;/a&gt; in the predictor variables. This can be triggered by having two or more perfectly correlated predictor variables (e.g. if the same predictor variable is mistakenly given twice, either without transforming one of the copies or by transforming one of the copies linearly). It can also happen if there is too little data available compared to the number of parameters to be estimated (e.g. fewer data points than regression coefficients). In the case of multicollinearity, the parameter vector \( \beta \) will be non-identifiable—it has no unique solution. At most we will be able to identify some of the parameters, i.e. narrow down its value to some linear subspace of \( R^p \). See partial least squares regression. Methods for fitting linear models with multicollinearity have been developed; some require additional assumptions such as "effect sparsity"—that a large fraction of the effects are exactly zero.      &lt;br&gt;
Note that the more computationally expensive iterated algorithms for parameter estimation, such as those used in generalized linear models, do not suffer from this problem—and in fact it's quite normal when handling categorically valued predictors to introduce a separate indicator variable predictor for each possible category, which inevitably introduces multicollinearity.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Beyond these assumptions, several other statistical properties of the data strongly influence the performance of different estimation methods:   &lt;br&gt;
- The statistical relationship between the error terms and the regressors plays an important role in determining whether an estimation procedure has desirable sampling properties such as being unbiased and consistent.     &lt;br&gt;
- The arrangement, or probability distribution of the predictor variables \( x \) has a major influence on the precision of estimates of \( \beta \). Sampling and design of experiments are highly developed subfields of statistics that provide guidance for collecting data in such a way to achieve a precise estimate of \( \beta \).        &lt;/p&gt;&lt;/div&gt;</description><guid>https://chowy1026.github.io/course-notes/machine-learning/06-supervised_learning-regression/</guid><pubDate>Wed, 19 Apr 2017 22:19:50 GMT</pubDate></item></channel></rss>